use eyre::{Context, Result};
use std::{
    cell::RefCell,
    collections::{HashMap, HashSet, VecDeque},
    sync::{atomic::AtomicBool, Arc},
};
use tokio::task::JoinHandle;

use egui::{Pos2, Rect};
use surfer_translation_types::translator::VariableNameInfo;

use crate::{
    command_prompt,
    config::SurferConfig,
    displayed_item::DisplayedItemRef,
    message::Message,
    state::UserState,
    time::TimeUnit,
    translation::{all_translators, TranslatorList},
    variable_filter::VariableFilter,
    wave_container::VariableRef,
    wave_source::LoadProgress,
    CachedDrawData, CanvasState, Channels, WcpClientCapabilities,
};

#[cfg(feature = "performance_plot")]
use crate::benchmark::Timing;

pub struct SystemState {
    pub user: UserState,

    /// Which translator to use for each variable
    pub(crate) translators: TranslatorList,
    /// Channels for messages generated by other threads
    pub channels: Channels,

    /// Tracks progress of file/variable loading operations.
    pub(crate) progress_tracker: Option<LoadProgress>,

    /// Buffer for the command input
    pub(crate) command_prompt: command_prompt::CommandPrompt,

    /// The context to egui, we need this to change the visual settings when the config is reloaded
    pub(crate) context: Option<Arc<egui::Context>>,

    /// List of batch messages which will executed as soon as possible
    pub(crate) batch_messages: VecDeque<Message>,
    pub(crate) batch_messages_completed: bool,

    /// The WCP server
    #[allow(unused)]
    pub(crate) wcp_server_thread: Option<JoinHandle<()>>,
    #[allow(unused)]
    pub(crate) wcp_server_address: Option<String>,
    #[allow(unused)]
    pub(crate) wcp_stop_signal: Arc<AtomicBool>,
    #[allow(unused)]
    pub(crate) wcp_running_signal: Arc<AtomicBool>,
    pub(crate) wcp_greeted_signal: Arc<AtomicBool>,
    pub(crate) wcp_client_capabilities: WcpClientCapabilities,

    /// The draw commands for every variable currently selected
    // For performance reasons, these need caching so we have them in a RefCell for interior
    // mutability
    pub(crate) draw_data: RefCell<Vec<Option<CachedDrawData>>>,

    pub(crate) variable_name_info_cache: RefCell<HashMap<VariableRef, Option<VariableNameInfo>>>,

    pub(crate) gesture_start_location: Option<Pos2>,

    pub(crate) measure_start_location: Option<Pos2>,

    // Egui requires a place to store text field content between frames
    pub(crate) url: RefCell<String>,
    pub(crate) command_prompt_text: RefCell<String>,
    pub(crate) last_canvas_rect: RefCell<Option<Rect>>,
    pub(crate) item_renaming_string: RefCell<String>,

    /// These items should be expanded into subfields in the next frame. Cleared after each
    /// frame
    pub(crate) items_to_expand: RefCell<Vec<(DisplayedItemRef, usize)>>,
    /// Character to add to the command prompt if it is visible. This is only needed for
    /// presentations at them moment.
    pub(crate) char_to_add_to_prompt: RefCell<Option<char>>,

    // Benchmarking stuff
    /// Invalidate draw commands every frame to make performance comparison easier
    pub(crate) continuous_redraw: bool,
    #[cfg(feature = "performance_plot")]
    pub(crate) rendering_cpu_times: VecDeque<f32>,
    #[cfg(feature = "performance_plot")]
    pub(crate) timing: RefCell<Timing>,

    // Undo and Redo stacks
    pub(crate) undo_stack: Vec<CanvasState>,
    pub(crate) redo_stack: Vec<CanvasState>,

    pub(crate) url_callback: Option<Box<dyn Fn(String) -> Message + Send + 'static>>,

    // Only used for testing
    pub(crate) expand_parameter_section: bool,
}

impl SystemState {
    pub fn new() -> Result<SystemState> {
        Self::new_inner(false)
    }

    #[cfg(test)]
    pub(crate) fn new_default_config() -> Result<SystemState> {
        Self::new_inner(true)
    }

    fn new_inner(force_default_config: bool) -> Result<SystemState> {
        let config = SurferConfig::new(force_default_config)
            .with_context(|| "Failed to load config file")?;
        let channels = Channels::new();

        // Basic translators that we can load quickly
        let translators = all_translators();

        let result = SystemState {
            user: UserState {
                config,
                waves: None,
                previous_waves: None,
                count: None,
                blacklisted_translators: HashSet::new(),
                show_about: false,
                show_keys: false,
                show_gestures: false,
                show_performance: false,
                show_license: false,
                show_logs: false,
                show_cursor_window: false,
                wanted_timeunit: TimeUnit::None,
                time_string_format: None,
                show_url_entry: false,
                show_quick_start: false,
                rename_target: None,
                show_reload_suggestion: None,
                variable_name_filter_focused: false,
                variable_filter: VariableFilter::new(),
                ui_zoom_factor: None,
                state_file: None,
                show_hierarchy: None,
                show_menu: None,
                show_ticks: None,
                show_toolbar: None,
                show_tooltip: None,
                show_scope_tooltip: None,
                show_default_timeline: None,
                show_overview: None,
                show_statusbar: None,
                show_variable_direction: None,
                show_open_sibling_state_file_suggestion: None,
                align_names_right: None,
                show_variable_indices: None,
                show_empty_scopes: None,
                show_parameters_in_scopes: None,
                highlight_focused: None,
                fill_high_values: None,
                drag_started: false,
                drag_source_idx: None,
                drag_target_idx: None,
                sidepanel_width: None,
                primary_button_drag_behavior: None,
                arrow_key_bindings: None,
                clock_highlight_type: None,
                hierarchy_style: None,
                autoload_sibling_state_files: None,
                autoreload_files: None,
            },
            translators,
            channels,
            progress_tracker: None,
            command_prompt: command_prompt::CommandPrompt {
                visible: false,
                suggestions: vec![],
                selected: 0,
                new_selection: None,
                new_cursor_pos: None,
                previous_commands: vec![],
            },
            context: None,
            wcp_server_thread: None,
            wcp_server_address: None,
            wcp_stop_signal: Arc::new(AtomicBool::new(false)),
            wcp_running_signal: Arc::new(AtomicBool::new(false)),
            wcp_greeted_signal: Arc::new(AtomicBool::new(false)),
            wcp_client_capabilities: WcpClientCapabilities::new(),
            gesture_start_location: None,
            measure_start_location: None,
            batch_messages: VecDeque::new(),
            batch_messages_completed: false,
            url: RefCell::new(String::new()),
            command_prompt_text: RefCell::new(String::new()),
            draw_data: RefCell::new(vec![None]),
            variable_name_info_cache: RefCell::new(HashMap::new()),
            last_canvas_rect: RefCell::new(None),
            item_renaming_string: RefCell::new(String::new()),

            items_to_expand: RefCell::new(vec![]),
            char_to_add_to_prompt: RefCell::new(None),
            expand_parameter_section: false,

            url_callback: None,
            continuous_redraw: false,
            #[cfg(feature = "performance_plot")]
            rendering_cpu_times: VecDeque::new(),
            #[cfg(feature = "performance_plot")]
            timing: RefCell::new(Timing::new()),
            undo_stack: vec![],
            redo_stack: vec![],
        };

        Ok(result)
    }
}

impl From<UserState> for SystemState {
    fn from(serializable_state: UserState) -> SystemState {
        let mut state = SystemState::new().unwrap();
        state.user = serializable_state;
        state
    }
}
